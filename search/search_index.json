{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Config-Segregate","text":"<p>The <code>config-segregate</code> library is designed to help you manage and load configuration files that are split into multiple files, potentially using different formats (e.g., JSON, YAML, TOML). This modular approach allows you to separate different parts of your configuration into their own files. The library also provides the ability to define a \"Base\" configuration and apply \"Updates\" on top of it, reducing duplication and simplifying configuration management. Also, it works well with Pydantic.</p>"},{"location":"#key-features","title":"Key Features:","text":"<ul> <li>Modular Configurations: Configurations can be split across multiple files, each of which can be in a different format, as long as they can be loaded as Python dictionaries.</li> <li>Base and Updates: You can define a base configuration and apply updates from other files on top of it. This approach supports nested updates, meaning that if the base contains nested dictionaries, the updates will not replace them entirely but will update them recursively.- Support for JSON, YAML, and TOML: Easily load configurations in multiple formats.</li> <li>Custom Readers: Extend the library by registering custom reader functions for additional file formats.</li> <li>Segregation Options: Control how configurations are merged, with options to disable nested updates or remove specific keys.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.8+</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip3 install config-segregate\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Suppose you have a configuration file <code>main_config.json</code> that references another file <code>base_config.json</code> and also includes settings from <code>settings.json</code>:</p> <pre><code>{\n    \"__base__\": \"${{ base_config.json }}\",\n    \"logging\": {\n        \"level\": \"DEBUG\",\n        \"settings\": \"${{ ./settings/settings.json }}\"\n    }\n}\n</code></pre> <p>In this example: - The <code>__base__</code> key references <code>base_config.json</code>, whose contents will be loaded and merged with <code>main_config.json</code>. - The <code>settings</code> key within the <code>logging</code> section references another file, <code>settings.json</code>, which will be loaded and included in the final configuration.</p> <p>You can mix and match file formats (e.g., the base file can be JSON, while the settings file can be YAML) as long as they can be loaded as Python dictionaries.</p>"},{"location":"#loading-the-configuration","title":"Loading the Configuration","text":"<p>To load and resolve any references within your configuration file, use the <code>load_config</code> function:</p> <pre><code>from config_loader import load_config\n\nconfig = load_config(\"path/to/main_config.json\")\nprint(config)\n</code></pre> <p>This function will: - Load <code>main_config.json</code>. - Resolve any referenced paths. - Apply updates from the file on top of the base configuration specified in the <code>__base__</code> key. - Return the final merged configuration as a Python dictionary.</p>"},{"location":"#toml-support","title":"TOML Support","text":"<p>If you need to work with TOML files, you can optionally install the <code>toml</code> library by using the <code>toml</code> extra:</p> <pre><code>$ pip3 install config-segregate[toml]\n# or\n$ pip3 install config-segregate[all]\n</code></pre> <p>This will enable support for reading TOML files with the <code>load_config</code> function.</p>"},{"location":"#segregation-options","title":"Segregation Options","text":"<p>The <code>config-segregate</code> library also provides options to control how configurations are merged. These options can be specified in your configuration files using the <code>__segregate_options__</code> key.</p>"},{"location":"#available-segregation-options","title":"Available Segregation Options","text":"<p>The <code>SegregateOptions</code> dictionary includes the following options:</p> <ul> <li><code>disable_nested_update</code>: A boolean flag that, when set to <code>True</code>, disables nested updates. Instead of updating nested dictionaries, the update will replace them entirely.</li> <li><code>remove_keys</code>: A list of keys that should be removed from the configuration during the update process.</li> </ul>"},{"location":"#example-usage-in-json","title":"Example Usage in JSON","text":"<p>Here\u2019s how you can specify these options in a JSON configuration file:</p> <pre><code>{\n    \"__base__\": \"${{ base_config.json }}\",\n    \"__segregate_options__\": {\n        \"disable_nested_update\": true,\n        \"remove_keys\": [\"obsolete_key\"]\n    },\n    \"logging\": {\n        \"level\": \"DEBUG\"\n    }\n}\n</code></pre> <p>In this example: - <code>disable_nested_update: true</code> means that any nested dictionaries in the base configuration will be replaced by the corresponding entries in this file. - <code>remove_keys: [\"obsolete_key\"]</code> indicates that the key <code>obsolete_key</code> should be removed from the base configuration during the update.</p>"},{"location":"#registering-custom-readers","title":"Registering Custom Readers","text":"<p>The library is extendable, allowing you to add support for custom file formats by registering your own reader functions.</p>"},{"location":"#example_1","title":"Example","text":"<p>Suppose you have a custom configuration format with a <code>.custom</code> extension. Here\u2019s how you could add support for it:</p> <pre><code>from config_loader import register_reader\n\ndef read_custom_file(path_to_file):\n    with open(path_to_file) as custom_file:\n        data = custom_file.read()\n        # Process your custom data format here and return as a dictionary\n        return process_custom_data(data)\n\nregister_reader(\".custom\", read_custom_file)\n</code></pre> <p>After registering, you can load <code>.custom</code> files just like any other supported format:</p> <pre><code>config = load_config(\"path/to/config.custom\")\n</code></pre>"},{"location":"#custom-reader-function-signature","title":"Custom Reader Function Signature","text":"<p>Your custom reader function should follow this signature:</p> <pre><code>def custom_reader_function(path_to_file: Path) -&gt; Dict[str, Any]:\n    # Your code to read and return data as a dictionary\n</code></pre> <p>This approach allows you to seamlessly extend the library's capabilities to handle any file format your project requires.</p>"}]}